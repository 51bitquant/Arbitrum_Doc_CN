# 排序器和抗审查性

排序器是一个特殊的 Arbitrum 全节点，在正常情况下，负责将用户的交易提交到 L2
系统。原则上，一个链的排序器可以采用不同的形式；正如 Arbitrum One
目前所代表的那样，排序器只是集中式的；最终，排序器将由各独立的分布式委员会组成最后达成共识。然而，无论其形式如何，定序器都有一个基本限制，它不能跟
Arbitrum 系统的任何其他部分有关联：它必须在自己的安全假设下运行；即它不能直接从第
1 获得安全性。这就引出了一个问题，即当定序器行为不端时，Arbitrum
如何保持其抗审查性的特性。

在这里，我们将描述任何用户如何完全绕过排序器以直接从L1提交任何 Arbitrum 交易（包括启动资金提取的交易）的机制，从而即使定序器完全没有响应或作恶也能保持抗审查性。

## 核心收件箱

当谈论“将交易提交到 Arbitrum
链中”时，那么我们说的就是将其包含到链的核心收件箱中，由SequencerInbox中的inboxAccs字节数组表示。
一旦交易被包含在核心收件箱中，它们的顺序就一成不变，它们的执行是完全确定的，我们可以无需信任地将结果状态视为具有
L1
级别的最终性（有关更多信息，请参阅[洞察 Arbitrum ](../../深入理解协议/洞悉Arbitrum.md#高屋建瓴)）。排序器的角色是关注之前发生的事情；即交易如何进入核心收件箱。
我们将把一个交易可能采取的路线分为两种情况：一个表现良好的排序器和一个有故障的排序器。

## 快乐/常见案例: 排序器是活的并且表现良好

在这里，我们首先假设排序器是完全可操作的，并且正在运行以尽可能安全和及时地处理用户的事务。排序器可以通过两种方式接收用户的交易——直接通过
RPC 请求，或者通过底层的 L1。

如果用户发布“标准”Arbitrum 交易（即与 L2 原生 dapp
交互），用户将直接将签名交易提交给排序器，就像用户在与 L1
交互时向以太坊节点提交交易一样.
收到它后，定序器将执行它并几乎立即向用户发送收据。不久之后——通常不超过几分钟——定序器会将用户的事务包含在一个批次中，并通过调用SequencerInbox的addSequencerL2Batch方法之一将其发布到
L1；请注意，只有定序器有权调用这些方法。此时交易具有 L1 级别的最终确定性。

或者，用户可以通过将 L2 消息发布到底层 L1 上来将其 L2
消息提交给排序器。如果用户希望与 L2 消息一起执行一些 L1
操作并保持两者之间的原子性，则此路径是必要的——这里的教科书示例是通过网桥进行代币存款（L1
上的托管，L2 上的铸币厂）。用户通过发布调用Inbox合约上的相关方法之一的 L1
交易（即向 L1
节点发送正常交易）来做到这一点；即，sendUnsignedTransaction。这会在我们称之为“延迟收件箱”的地方添加一条消息（由
Bridge
合约中的inboxAcc表示），它实际上是一个队列，消息在移动到核心收件箱之前等待.
在交易被包含在延迟的收件箱中大约 10 分钟后，排序器将发出 L2
收据（这种延迟的原因是为了最大限度地降低短期 L1 重组的风险，这可能会使排序器的 L2
收据无效。）同样，最后一个步骤是让排序器将 L2
消息包含在一个批次中——当调用批量提交方法时，排序器指定延迟收件箱中要包含多少条消息——最终确定事务。

总而言之——无论哪种情况，用户首先将他们的消息传递给排序器，后者反过来确保它到达核心收件箱。
Here, we start by assuming that the sequencer is fully operational, and
is running with the intent of processing users’ transactions in as safe
and timely a manner as possible. The sequencer can receive a user’s
transaction two ways — either directly via an RPC request, or via the
underlying L1.

If a user is posting a “standard” Arbitrum transaction (i.e., interacting with an L2 native dapp), the user will submit the signed transaction directly to the sequencer, much like how a user submits a transaction to an Ethereum node when interacting with L1. Upon receiving it, the sequencer will execute it and near-instantly deliver the user a receipt. Some short time later — [usually no more than a few minutes](https://arbiscan.io/batches) — the sequencer will include the user’s transaction in a batch and post it on L1 by calling one of the **SequencerInbox**’s **addSequencerL2Batch** methods; note that only the sequencer has the authority to call these methods. At this point the transactions have L1-level finality. 



Alternatively, a user can submit their L2 message to the sequencer by posting it on the underlying L1. This path is necessary if the user wishes to perform some L1 operation along with the L2 message and to preserve atomicity between the two — the textbook example here being a token deposit via a bridge (escrow on L1, mint on L2). The user does this by publishing an L1 transaction (i.e., sending a normal transaction to an L1 node) that calls one of the relevant methods on the **Inbox** contract; i.e., **sendUnsignedTransaction**. This adds a message onto what we’ll call “the delayed Inbox”, (represented by the **inboxAcc** in the Bridge contract), which is effectively a queue that messages wait in before being moved over to the core **Inbox**. The sequencer will emit an L2 receipt about ~10 minutes after the transaction has been included in the delayed Inbox (the reason for this delay is to minimize the risk of short term L1 reorgs which could invalidate the Sequencer’s L2 receipts.) Again, the last step is for the sequencer to include the L2 message in a batch — when calling the batch submission methods, the sequencer specifies how many messages in the delayed inbox to include — finalizing the transaction.

	
In sum — in either happy case, the user first delivers their message to the sequencer, who in turn ensures that it arrives in the core Inbox. 

## 不愉快/不常见的情况：排序器没有做好它的工作

现在让我们假设排序器，无论出于何种原因，完全无法执行其提交消息的任务。用户仍然可以通过两个步骤获得他们的交易：

首先，他们通过 L1 将他们的 L2 消息提交到如上所述的延迟收件箱中：请注意，虽然原子跨链消息是使用延迟收件箱的常见情况，但原则上它可以用于提交任何 L2 消息。

一旦进入延迟的收件箱，我们显然不能依赖排序器将翻译包含在批处理中。相反，我们可以使用SequencerInbox的forceInclusion方法。一旦消息在延迟收件箱中的时间足够长，就可以调用forceInclusion将其从延迟收件箱移动到核心收件箱中，此时它已完成。至关重要的是，任何地址都可以调用forceInclusion。

目前，在 Arbitrum One 上，提交和强制包含之间的延迟时间大约为 24 小时，由maxDelayBlocks和maxDelaySeconds变量指定。来自 L1 的强制包含将直接影响任何未确认的 L2 交易的状态；保持保守的高价值确保它只应在特殊情况下使用。

除了延迟本身之外，forceInclusion路径还存在交易排序不确定性的缺点；即，在等待消息最大延迟通过时，恶意排序器原则上可以直接在其前面发布消息。然而，排序器最终无法阻止它被包含在核心收件箱中，此时它的排序已完成。

虽然缓慢、“不愉快”的路径并不是最优的，并且应该很少（如果有的话）是必要的，但它作为一个选项的可用性确保了 Arbitrum 始终保持其去信任的安全模型，即使系统的许可部分出现故障。
Now let’s suppose the sequencer, for whatever reason, is entirely failing to carry out its task of submitting messages. A user can still get their transaction included in two steps:

First, they submit their L2 message via L1 into the delayed Inbox as described above: note that although atomic cross-chain messages are the common case for using the delayed Inbox, it can in principle be used to submit any L2 message. 

Once in the delayed Inbox, we obviously can’t rely on the sequencer to include the translation in a batch. Instead, we can use **SequencerInbox**’s **forceInclusion** method. Once a message has been in the delayed Inbox for a sufficient amount of time **forceInclusion** can be called to move it from the delayed Inbox into the core Inbox, at which point it’s finalized. Crucially, any address can call **forceInclusion**. 

Currently, on Arbitrum One, this delay time between submission and force inclusion is roughly 24 hours, as specified by the **maxDelayBlocks** and **maxDelaySeconds** variables. A force inclusion from L1 would directly affect the state for any unconfirmed L2 transactions; keeping conservatively high value ensures it should only be used under extraordinary circumstances.

On top of the delay itself, the **forceInclusion** path has the downside of uncertainty around transaction ordering; i.e., while waiting for a messages max delay to pass, a malicious sequencer could, in principle, directly post messages in front of it. However, there’s ultimately nothing the sequencer can do to stop it from being included in the core Inbox, at which point its ordering is finalized.
	
While the slow, “unhappy” path isn’t optimal, and should rarely, if ever, be necessary, its availability as an option ensures Arbitrum always preserves its trustless security model, even if the permissioned parts of the system act faulty.